#' @keywords internal
uniPara <- function(yu, mu, au, s1 = c(1, -1), s2 = c(1, -1)){
  d1 = length(yu)
  d2 = length(mu)
  d3 = length(au)
  d4 = length(s1)
  d5 = length(s2)
  out = matrix(nrow = d1 * d2 * d3 * d4 * d5, ncol = 5)
  out[, 5] = rep(s2, d1 * d2 * d3 * d4)
  out[, 4] = rep(rep(s1, each = d5), d1 * d2 * d3)
  out[, 3] = rep(rep(au, each = d4 * d5), d1 * d2)
  out[, 2] = rep(rep(mu, each = d3 * d4 * d5), d1)
  out[, 1] = rep(yu, each = d2 * d3 * d4 * d5)
  out = rbind(matrix(rep(0, 5), nrow = 1), out)
  return(out)
}

#' @keywords internal
uniParaShortcut <- function(ru, s1 = c(1, -1), s2 = c(1, -1)){
  out = matrix(rep(0, 5), nrow = 1)
  for (s1i in s1)
    for (s2i in s2){
      out = rbind(out, cbind(ru, s1i, s2i))
    }
  return(out)
}

#' @keywords internal
uniDirectPointEstimate <- function(y, m, a, c = NULL, para){
  if (!is.null(c)){
    y = lm(y~c)$residuals
    a = lm(a~c)$residuals
    m = lm(m~c)$residuals
  }
  else{
    y = lm(y~1)$residuals
    a = lm(a~1)$residuals
    m = lm(m~1)$residuals
  }
  mac = cor(m, a)^2
  A = sqrt(para[, 2] * (1 - para[, 3]) * (1 - mac))
  A = A + para[, 5] * sqrt(para[, 3] * mac)
  A = 1 - A^2
  A = (1 - para[, 3]) * (1 - para[, 2]) / A
  aucm = 1 - A
  aucm = pmin(aucm, 1)
  aucm = pmax(aucm, 0)
  A = aucm / (1 - aucm)
  A = sqrt(para[, 1] * A)
  theta1hat = lm(y~a+m)$coefficients[2] + para[, 4] * A * sd(lm(y~a+m)$residuals) / sd(lm(a~m)$residuals)
  return(theta1hat)
}

#' @keywords internal
uniIndirectPointEstimate <- function(y, m, a, c = NULL, para){
  if (!is.null(c)){
    y = lm(y~c)$residuals
    a = lm(a~c)$residuals
    m = lm(m~c)$residuals
  }
  else{
    y = lm(y~1)$residuals
    a = lm(a~1)$residuals
    m = lm(m~1)$residuals
  }
  A = para[, 3] / (1 - para[, 3])
  A = para[, 2] * A
  A = sqrt(A)
  beta1hat = lm(m~a)$coefficients[2] +
    para[, 4] * A * sd(lm(m~a)$residuals) / sd(a)
  A = para[, 2] / (1 - para[, 2])
  A = para[, 1] * A
  A = sqrt(A)
  theta3hat = lm(y~a+m)$coefficients[3] +
    para[, 5] * A * sd(lm(y~a+m)$residuals) / sd(lm(m~a)$residuals)
  return(beta1hat * theta3hat)
}


#' Sensitivity analysis for the Baron-Kenny approach with a single mediator
#' @param y a vector of the outcome variable
#' @param m a vector of the mediator variable
#' @param a a vector of the treatment variable
#' @param c a vector or matrix of the covariates
#' @param r2.max the maximum r^2 to be considered for the grid search
#' @param randomized.a if the treatment is randomized
#' @param s1 (optional) the pre-specified sign S1; see Zhang and Ding (2022)
#' @param s2 (optional) the pre-specified sign S2; see Zhang and Ding (2022)
#' @param s3 (optional) the pre-specified sign S3; see Zhang and Ding (2022)
#' @param s4 (optional) the pre-specified sign S4; see Zhang and Ding (2022)
#' @param B the number of bootstrap resampling
#' @param shortcut if use the shortcut approach
#' @param progress.display if display the progress
#' @return a summary table, and the point estimates, standard errors, t statistics
#' of the direct and indirect effects with sensitivity parameters generated by
#' the grid search.
#' @examples
#' set.seed(1234)
#' a = rnorm(1000)
#' m = 0.2 * a + rnorm(1000)
#' u = (-sqrt(1/3.2) - 0.1) * a + 0.5 * m + rnorm(1000)
#' y = 0.5 * u + rnorm(1000)
#' cor(a, u)^2
#' cor(lm(m~a)$residual, lm(u~a)$residual)^2
#' cor(lm(y~m+a)$residual, lm(u~m+a)$residual)^2
#' result = bku(y, m, a)
#' result$coefficients
#' @importFrom stats lm cor pnorm sd
#' @importFrom svMisc progress
#' @export
bku <- function(y, m, a, c = NULL, r2.max = 0.5,
                randomized.a = FALSE,
                s1 = c(1, -1), s2 = c(1, -1),
                s3 = c(1, -1), s4 = c(1, -1),
                B = 500, shortcut = FALSE,
                progress.display = TRUE){

  n = length(y)
  if (shortcut){
    if (r2.max < 0.01){
      ru = matrix(c(0, 0, 0), nrow = 1)
    }else{
      ru = matrix(rep(seq(0.01, r2.max, by = 0.01), 3), ncol = 3)
    }
    if (randomized.a){
      ru[, 3] = 0
    }
    para.direct = uniParaShortcut(ru, s1, s2)
    para.indirect = uniParaShortcut(ru, s3, s4)
  }else{
    if (r2.max < 0.01){
      au = 0
      mu = 0
      yu = 0
    }else{
      au = seq(0.01, r2.max, by = 0.01)
      mu = seq(0.01, r2.max, by = 0.01)
      yu = seq(0.01, r2.max, by = 0.01)
    }

    if (randomized.a){
      au = 0
    }

    para.direct = uniPara(yu, mu, au, s1, s2)
    para.indirect = uniPara(yu, mu, au, s3, s4)
  }

  point.direct <- uniDirectPointEstimate(y, m, a, c, para.direct)
  point.indirect <- uniIndirectPointEstimate(y, m, a, c, para.indirect)
  se.direct <- rep(0, length = length(point.direct))
  se.indirect <- rep(0, length = length(point.indirect))
  for (i in c(1: B)){
    if (progress.display)
      svMisc::progress(i, B)
    ind = sample(n, n, replace = T)
    se.direct <- se.direct + (point.direct -
                                uniDirectPointEstimate(y[ind], m[ind], a[ind], c[ind, ], para.direct))^2 / (B-1)
    se.indirect <- se.indirect + (point.indirect -
                                    uniIndirectPointEstimate(y[ind], m[ind], a[ind], c[ind, ], para.indirect))^2 / (B-1)
  }
  if (progress.display)
    svMisc::progress(i+1, B)
  se.direct = sqrt(se.direct)
  se.indirect = sqrt(se.indirect)
  t.direct = point.direct / se.direct
  t.indirect = point.indirect / se.indirect

  out = matrix(NA, nrow = 2, ncol = 6)
  out[1, 1] = point.direct[1]
  out[1, 2] = se.direct[1]
  out[1, 3] = t.direct[1]
  out[1, 4] = 2 * pnorm(-abs(t.direct[1]), lower.tail = T)
  out[2, 1] = point.indirect[1]
  out[2, 2] = se.indirect[1]
  out[2, 3] = t.indirect[1]
  out[2, 4] = 2 * pnorm(-abs(t.indirect[1]), lower.tail = T)

  maxru2 = apply(para.direct[, 1: 3], 1, max)
  ind = which(t.direct * sign(out[1, 1]) <= 1.96)
  if (length(ind) > 0)
    out[1, 5] = min(maxru2[ind])
  ind = which(t.direct * sign(out[1, 1]) <= 0)
  if (length(ind) > 0)
    out[1, 6] = min(maxru2[ind])

  maxru2 = apply(para.indirect[, 1: 3], 1, max)
  ind = which(t.indirect * sign(out[2, 1]) <= 1.96)
  if (length(ind) > 0)
    out[2, 5] = min(maxru2[ind])
  ind = which(t.indirect * sign(out[2, 1]) <= 0)
  if (length(ind) > 0)
    out[2, 6] = min(maxru2[ind])

  para.direct = para.direct[-1, ]
  point.direct = point.direct[-1]
  se.direct = se.direct[-1]
  t.direct = t.direct[-1]
  para.indirect = para.indirect[-1, ]
  point.indirect = point.indirect[-1]
  se.indirect = se.indirect[-1]
  t.indirect = t.indirect[-1]

  colnames(out) = c("Estimate", "Std. Error", "t value", "Pr(>|t|)", "R value for C.I.", "R value for Est.")
  rownames(out) = c("Direct effect", "Indirect effect")
  print.out = as.data.frame(out)
  print.out[1, 4] = format.pval(out[1, 4], digits = 3)
  print.out[2, 4] = format.pval(out[2, 4], digits = 3)
  for (i in c(1,2,3,5,6))
    print.out[, i] = round(out[, i], 3)

  print(print.out)
  return(list("coefficients" = out,
              "para.direct" = para.direct,
              "para.indirect" = para.indirect,
              "point.direct" = point.direct,
              "point.indirect" = point.indirect,
              "se.direct" = se.direct,
              "se.indirect" = se.indirect,
              "t.direct" = t.direct,
              "t.indirect" = t.indirect))
}


#' @keywords internal
multiParaGen <- function(q, N){
  out = matrix(runif(N*q, -1, 1), nrow = N, ncol = q)
  out[, 1] = abs(out[, 1])
  r = 1 / apply(out, 1, function(x) sqrt(sum(x^2)))
  out = out * r
  return(out)
}

#' @keywords internal
multiPara <- function(yu, sqrt.mu, au, s1 = c(1, -1), s2 = c(1, -1)){
  d1 = length(yu)
  d2 = dim(sqrt.mu)[1]
  q = dim(sqrt.mu)[2]
  d3 = length(au)
  d4 = length(s1)
  d5 = length(s2)
  out = matrix(nrow = d1 * d2 * d3 * d4 * d5, ncol = q+4)
  out[, q+4] = rep(s2, d1 * d2 * d3 * d4)
  out[, q+3] = rep(rep(s1, each = d5), d1 * d2 * d3)
  out[, q+2] = rep(rep(au, each = d4 * d5), d1 * d2)
  for (i in c(1: q))
    out[, i+1] = rep(rep(sqrt.mu[, i], each = d3 * d4 * d5), d1)
  out[, 1] = rep(yu, each = d2 * d3 * d4 * d5)
  out = rbind(matrix(rep(0, q+4), nrow = 1), out)
  return(out)
}

#' @keywords internal
multiParaShortcut <- function(ru, q, s1 = c(1, -1), s2 = c(1, -1)){
  out = matrix(rep(0, q+4), nrow = 1)
  for (s1i in s1)
    for (s2i in s2){
      out = rbind(out, cbind(ru, s1i, s2i))
    }
  return(out)
}

#' @keywords internal
msqrt <- function(x){
  eg = eigen(x)
  return(eg$vectors %*% diag(sqrt(eg$values), nrow = length(eg$values)) %*% t(eg$vectors))
}

#' @keywords internal
multiDirectPointEstimate <- function(y, m, a, c = NULL, para){
  m = as.matrix(m)
  q = dim(m)[2]
  if (!is.null(c)){
    y = lm(y~c)$residuals
    a = lm(a~c)$residuals
    m = lm(m~c)$residuals
  }
  else{
    y = lm(y~1)$residuals
    a = lm(a~1)$residuals
    m = lm(m~1)$residuals
  }
  sqrtcovm = msqrt(var(m))
  sqrtcovma = msqrt(var(lm(m~a)$residuals))
  sqrtmac = cov(a, m) %*% solve(sqrtcovm) / sd(a)
  if (sum(sqrtmac^2) != 0)
    sqrtmac = sign(sqrtmac[min(which(sqrtmac != 0))]) * sqrtmac
  A = as.matrix(para[, 2: (q+1)]) %*% sqrtcovma %*% solve(sqrtcovm) * sqrt(1-para[, q+2])
  B = as.matrix(sqrt(para[, q+2])) %*% sqrtmac * para[, q+4]
  C = (1 - para[, q+2]) * (1 - apply(as.matrix(para[, 2: (q+1)])^2, 1, sum))
  aucm = 1 -  C / (1 - apply((A+B)^2, 1, sum))
  aucm = pmin(aucm, 1)
  aucm = pmax(aucm, 0)
  D = para[, q+3] * sqrt(para[, 1] * aucm / (1 - aucm))
  theta1hat = lm(y~a+m)$coefficients[2] +
    D * sd(lm(y~a+m)$residuals) / sd(lm(a~m)$residuals)
  return(theta1hat)
}

#' @keywords internal
multiIndirectPointEstimate <- function(y, m, a, c = NULL, para){
  m = as.matrix(m)
  N = dim(para)[1]
  q = dim(m)[2]
  if (!is.null(c)){
    y = lm(y~c)$residuals
    a = lm(a~c)$residuals
    m = lm(m~c)$residuals
  }
  else{
    y = lm(y~1)$residuals
    a = lm(a~1)$residuals
    m = lm(m~1)$residuals
  }
  sqrtcovma = msqrt(var(lm(m~a)$residuals))
  A = sqrt(para[, q+2] / (1-para[, q+2])) * para[, q+3] / sd(a)
  beta1hat = matrix(rep(lm(m~a)$coefficients[2, ], each = N), nrow = N)
  beta1hat = beta1hat + as.matrix(para[, 2:(q+1)]) %*% sqrtcovma * A
  A = sqrt(1 - apply(as.matrix(para[, 2: (q+1)])^2, 1, sum))
  A = sqrt(para[, 1]) / A * para[, q+4] * sd(lm(y~a+m)$residuals)
  theta3hat = matrix(rep(lm(y~a+m)$coefficients[3: (q+2)], each = N), nrow = N)
  theta3hat = theta3hat + as.matrix(para[, 2:(q+1)]) %*% solve(sqrtcovma) * A
  return(apply(beta1hat * theta3hat, 1, sum))
}

#' Sensitivity analysis for the Baron-Kenny approach with multiple mediators
#' @param y a vector of the outcome variable
#' @param m a matrix of the mediator variables
#' @param a a vector of the treatment variable
#' @param c a vector or matrix of the covariates
#' @param r2.max the maximum r^2 to be considered for the grid search
#' @param randomized.a if the treatment is randomized
#' @param s1 (optional) the pre-specified sign S1; see Zhang and Ding (2022)
#' @param s5 (optional) the pre-specified sign S5; see Zhang and Ding (2022)
#' @param s6 (optional) the pre-specified sign S6; see Zhang and Ding (2022)
#' @param s7 (optional) the pre-specified sign S7; see Zhang and Ding (2022)
#' @param B the number of bootstrap resampling
#' @param N the number of Monte Carlo sampling to generate \eqn{R_{m\sim u\mid a,c}^2} given fixed \eqn{R_{u\sim m\mid a,c}^2}
#' @param progress.display if display the progress
#' @param shortcut if use the shortcut approach
#' @return a summary table, and the point estimates, standard errors, t statistics
#' of the direct and indirect effects with sensitivity parameters generated by
#' the grid search.
#' @examples
#' set.seed(1234)
#' a = rnorm(1000)
#' m1 = 0.2 * a + rnorm(1000)
#' m2 = 0.3 * a + rnorm(1000)
#' m = cbind(m1, m2)
#' u = (sqrt(1/3.2)-sqrt(1/8)*0.5) * a + sqrt(1/8) * m1 + sqrt(1/8) * m2 + rnorm(1000)
#' y = 0.5 * u + rnorm(1000)
#' cor(a,u)^2
#' cor(lm(y~a+m)$residuals, lm(u~a+m)$residuals)^2
#' 1 - var(lm(u~a+m)$residuals) / var(lm(u~a)$residuals)
#' result = bkuvm(y, m, a, shortcut = TRUE)
#' result$coefficients
#' @importFrom stats lm cor pnorm sd cov runif var
#' @importFrom svMisc progress
#' @export
bkuvm <- function(y, m, a, c = NULL, r2.max = 0.5,
                  randomized.a = FALSE,
                  s1 = c(1, -1), s5 = c(1, -1),
                  s6 = c(1, -1), s7 = c(1, -1),
                  B = 500, N = 10, shortcut = FALSE,
                  progress.display = TRUE){
  m = as.matrix(m)
  n = length(y)
  q = dim(m)[2]

  if (shortcut){
    if (r2.max < 0.01){
      ru = matrix(rep(0, q+2), nrow = 1)
    }else{
      sqrt.mu = matrix(nrow = N * length(seq(0.01, r2.max, by = 0.01)), ncol = q)
      unit.sqrt.mu = multiParaGen(q, N)
      for (i in c(1: length(seq(0.01, r2.max, by = 0.01)))){
        sqrt.mu[((i-1)*N+1):(i*N),] = unit.sqrt.mu * sqrt(seq(0.01, r2.max, by = 0.01)[i])
      }
      ru = matrix(nrow = N * length(seq(0.01, r2.max, by = 0.01)), ncol = q+2)
      ru[, 1] = rep(seq(0.01, r2.max, by = 0.01), each = N)
      ru[, q+2] = rep(seq(0.01, r2.max, by = 0.01), each = N)
      ru[, 2:(q+1)] = sqrt.mu
    }
    if (randomized.a){
      ru[, q+2] = 0
    }
    para.direct = multiParaShortcut(ru, q, s1, s5)
    para.indirect = multiParaShortcut(ru, q, s6, s7)
  }else{
    if (r2.max < 0.01){
      au = 0
      sqrt.mu = matrix(rep(0, q), nrow = 1)
      yu = 0
    }else{
      sqrt.mu = matrix(nrow = N * length(seq(0.01, r2.max, by = 0.01)), ncol = q)
      unit.sqrt.mu = multiParaGen(q, N)
      for (i in c(1: length(seq(0.01, r2.max, by = 0.01)))){
        sqrt.mu[((i-1)*N+1):(i*N),] = unit.sqrt.mu * sqrt(seq(0.01, r2.max, by = 0.01)[i])
      }
      au = seq(0.01, r2.max, by = 0.01)
      yu = seq(0.01, r2.max, by = 0.01)
    }

    if (randomized.a){
      au = 0
    }

    para.direct = multiPara(yu, sqrt.mu, au, s1, s5)
    para.indirect = multiPara(yu, sqrt.mu, au, s6, s7)
  }

  point.direct <- multiDirectPointEstimate(y, m, a, c, para.direct)
  point.indirect <- multiIndirectPointEstimate(y, m, a, c, para.indirect)
  se.direct <- rep(0, length = length(point.direct))
  se.indirect <- rep(0, length = length(point.indirect))
  for (i in c(1: B)){
    if (progress.display)
      svMisc::progress(i, B)
    ind = sample(n, n, replace = T)
    se.direct <- se.direct + (point.direct -
                                multiDirectPointEstimate(y[ind], m[ind, ], a[ind], c[ind, ], para.direct))^2 / (B-1)
    se.indirect <- se.indirect + (point.indirect -
                                    multiIndirectPointEstimate(y[ind], m[ind, ], a[ind], c[ind, ], para.indirect))^2 / (B-1)
  }
  if (progress.display)
    svMisc::progress(i+1, B)
  se.direct = sqrt(se.direct)
  se.indirect = sqrt(se.indirect)
  t.direct = point.direct / se.direct
  t.indirect = point.indirect / se.indirect

  out = matrix(NA, nrow = 2, ncol = 6)
  out[1, 1] = point.direct[1]
  out[1, 2] = se.direct[1]
  out[1, 3] = t.direct[1]
  out[1, 4] = 2 * pnorm(-abs(t.direct[1]), lower.tail = T)
  out[2, 1] = point.indirect[1]
  out[2, 2] = se.indirect[1]
  out[2, 3] = t.indirect[1]
  out[2, 4] = 2 * pnorm(-abs(t.indirect[1]), lower.tail = T)

  maxru2 = pmax(apply(para.direct[, c(1, q+2)], 1, max), apply(as.matrix(para.direct[, 2: (q+1)]^2), 1, sum))
  ind = which(t.direct * sign(out[1, 1]) <= 1.96)
  if (length(ind) > 0)
    out[1, 5] = min(maxru2[ind])
  ind = which(t.direct * sign(out[1, 1]) <= 0)
  if (length(ind) > 0)
    out[1, 6] = min(maxru2[ind])

  maxru2 = pmax(apply(para.indirect[, c(1, q+2)], 1, max), apply(as.matrix(para.indirect[, 2: (q+1)]^2), 1, sum))
  ind = which(t.indirect * sign(out[2, 1]) <= 1.96)
  if (length(ind) > 0)
    out[2, 5] = min(maxru2[ind])
  ind = which(t.indirect * sign(out[2, 1]) <= 0)
  if (length(ind) > 0)
    out[2, 6] = min(maxru2[ind])

  para.direct = para.direct[-1, ]
  point.direct = point.direct[-1]
  se.direct = se.direct[-1]
  t.direct = t.direct[-1]
  para.indirect = para.indirect[-1, ]
  point.indirect = point.indirect[-1]
  se.indirect = se.indirect[-1]
  t.indirect = t.indirect[-1]

  colnames(out) = c("Estimate", "Std. Error", "t value", "Pr(>|t|)", "R value for C.I.", "R value for Est.")
  rownames(out) = c("Direct effect", "Indirect effect")
  print.out = as.data.frame(out)
  print.out[1, 4] = format.pval(out[1, 4], digits = 3)
  print.out[2, 4] = format.pval(out[2, 4], digits = 3)
  for (i in c(1,2,3,5,6))
    print.out[, i] = round(out[, i], 3)

  print(print.out)
  return(list("coefficients" = out,
              "para.direct" = para.direct,
              "para.indirect" = para.indirect,
              "point.direct" = point.direct,
              "point.indirect" = point.indirect,
              "se.direct" = se.direct,
              "se.indirect" = se.indirect,
              "t.direct" = t.direct,
              "t.indirect" = t.indirect))
}
